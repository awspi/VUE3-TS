# 02_Learn_Vue组件化

## Vue的开发模式

**随着项目越来越复杂，我们会采用组件化的方式来进行开发:**

在真实开发中，我们可以通过一个后缀名为 .vue 的**single-file components** (单文件组件) 来解决，并且可以使用webpack或者vite或者rollup等构建工具来对其进行处理。

**单文件的特点**

- 代码的高亮;
- ES6、CommonJS的模块化能力;
- 组件作用域的CSS;
- 可以使用预处理器来构建更加丰富的组件，比 如TypeScript、Babel、Less、Sass等;

**如何支持SFC**

- 方式一:使用**Vue CLI**来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件; 
- 方式二:自己使用**webpack**或rollup或vite这类打包工具，对其进行打包处理;

最通常都会采用**Vue CLI的**方式来完成。

**组件化的思想**

- 将一个完整的页面分成很多个组件;
- 每个组件都用于实现页面的一个功能块;
- 而每一个组件又可以进行细分
- 而组件本身又可以在多个地方进行复用;

Vue.createApp函数传入了一个对象App，这个**对象其实本质上就是一个组件**，也是我们应用程序的**根组件**;

组件化提供了一种抽象，让我们可以开发出一个个**独立可复用的小组件**来构造我们的应用; 

任何的应用都会被抽象成一颗**组件树**;

![image-20220614143430649](/Users/wsp/Library/Application Support/typora-user-images/image-20220614143430649.png)



## 注册组件的方式

**注册组件分成两种:**

- 全局组件:在任何其他的组件中都可以使用的组件;
- 局部组件:只有**在注册的组件**中才能使用的组件;

### 注册全局组件

全局组件需要使用**全局创建的app来注册组件;**

通过**`component`**方法**传入组件名称、组件对象**即可注册一个全局组件了;

之后，我们可以**在App组件**的**template**中直接使用这个全局组件:

![image-20220614144450537](/Users/wsp/Library/Application Support/typora-user-images/image-20220614144450537.png)

#### **全局组件的逻辑**

**组件本身也可以有自己的代码逻辑:**比如自己的data、computed、methods等等

![image-20220614144550909](/Users/wsp/Library/Application Support/typora-user-images/image-20220614144550909.png)

#### 组件的名称

在通过app.component注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种:

- 使用 kebab-case (短横线分隔命名) 定义一个组件时，在**引用这个自定义元素时**必须使用 kebab-case， 例如 ` <my-component-name>;`
- 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在**引用这个自定义元素时都可以使用**。
  - 也就是说 `<my-component-name>` 和 `<MyComponentName>` 都是可接受的;

### 注册局部组件

全局组件往往是在应用程序一开始就会**全局组件**完成，那么就意味着如果**某些组件我们并没有用到**，**也会一起被注册:**

webpack这种打包工具在打包项目时，依然会对其进行打包;


**所以在开发中我们通常使用组件的时候采用的都是局部注册:**

局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册;

**App组件中**，我们有data、computed、methods等选项了，事实上还可以有一个**components选项;**

该components选项对应的是一个对象，对象中的键值对是 **`组件的名称: 组件对象`**

![image-20220614145347455](/Users/wsp/Library/Application Support/typora-user-images/image-20220614145347455.png)



# Webpack

![image-20220621021031583](/Users/wsp/Library/Application Support/typora-user-images/image-20220621021031583.png)

**webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序;**

webpack的官方文档是https://webpack.js.org/ 

webpack的中文官方文档是https://webpack.docschina.org/

## 安装

webpack的安装目前分为两个:webpack、webpack-cli

```bash
npm install webpack webpack-cli –g # 全局安装 
npm install webpack webpack-cli –D # 局部安装
```

**webpack、webpack-cli的关系**

- 执行webpack命令，会执行node_modules下的.bin目录下的webpack;
- webpack在执行时是依赖webpack-cli的，如果没有安装就会报错;
- 而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程;
- 所以在安装webpack时，我们需要同时安装webpack-cli(第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西)

![image-20220621012108585](/Users/wsp/Library/Application Support/typora-user-images/image-20220621012108585.png)

## 默认打包

我们可以通过**webpack**进行打包，之后运行打包之后的代码

在目录下直接执行 **`webpack`** 命令

**生成一个dist文件夹，里面存放一个main.js的文件，就是我们打包之后的文件:**

**入口**

事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口;

所以，如果当前项目中没有存在src/index.js文件，那么会报错;

## 创建局部的webpack

前面我们直接执行webpack命令使用的是全局的webpack，如果希望使用局部的可以按照下面的步骤来操作。

- 第一步:创建package.json文件，用于管理项目的信息、库依赖等 **npm init**

- 第二步:安装局部的webpack **npm install webpack webpack-cli -D**

- 第三步:使用局部的webpack **npm webpack**

- 第四步:在package.json中创建scripts脚本，执行脚本打包即可

  - ```json
      "scripts": {
        "build":"webpack"
      }
    ```

    **npm run build**

## Webpack配置文件

在通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然 是不可以的。

可以在根目录下创建一个**webpack.config.js**文件，来作为webpack的配置文件:

```
const path =require('path')

module.exports={
  entry:"./src/main.js",//入口文件
  output:{
    filename:"bundle.js",//打包后的文件名
    path:path.resolve(__dirname,'./build')//打包的目录
  }
}
```

### 指定配置文件

通过 --config 来指定对应的配置文件 wk.config.js

```bash
webpack --config wk.config.js
```

在package.json中增加一个新的脚本,之后我们执行 npm run build来打包即可。

```json
  "scripts": {
    "build":"webpack --config wk.config.js"
  }
```



## Webpack的依赖图

 webpack到底是如何对我们的项目进行打包的呢?

事实上webpack在处理应用程序时，它会根据命令或者配置文件找到入口文件;

从入口开始，会生成一个**依赖关系图**，这个依赖关系图会包含应用程序中所需的所有模块(比如.js文件、css文件、图片、字体等);

然后遍历图结构，打包一个个模块**(根据文件的不同使用不同的loader来解析);**

**loader**是什么呢?

- loader 可以用于对模块的源代码进行转换

![image-20220621021031583](/Users/wsp/Library/Application Support/typora-user-images/image-20220621021031583.png)

## css-loader

- 可以将css文件也看成是一个模块，我们是通过import来加载这个模块的;
- 在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的loader来完成这个功能;
- 对于加载css文件来说，我们需要一个可以读取css文件的loader **最常用的是css-loader;**

**css-loader的安装:**

```bash
npm install css-loader -D
```

### css-loader的使用方案

- 内联方式;
- CLI方式(webpack5中不再使用);
- **配置方式;**

**内联方式:内联方式使用较少，因为不方便管理;**

- 在引入的样式前加上使用的loader，并且使用!分割;

  ```js
  import "css-loader!../css/style.css"
  ```

**CLI方式**

- 在webpack5的文档中已经没有了**--module-bind**; 
- 实际应用中也比较少使用，因为不方便管理;

#### loader配置方式(常用)

在我们的**webpack.config.js**文件中写明配置信息:

**module.rules**中允许我们配置多个loader(因为我们也会继续使用其他的loader，来完成其他文件的加载); 

这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览;

**<u>module.rules</u>的配置如下:**

- rules属性对应的值是一个数组:**[Rule]**
  - 数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性:
- **test属性**:用于对 resource(资源)进行匹配的，通常会设置成**正则表达式;** 
- **use属性**:对应的值时一个数组:**[UseEntry]**
- UseEntry是一个对象，可以通过对象的属性来设置一些其他属性
  - **loader:必须有一个 loader属性，对应的值是一个字符串;**
  - **options**:可选的属性，值是一个字符串或者对象，值会被传入到loader中;
  - **query**:目前已经使用options来替代;
- **传递字符串(如:use: [ 'style-loader' ])是 loader 属性的简写方式(如:use: [ { loader: 'style-loader'} ]);** 
- **loader属性:** Rule.use: [ { loader } ] 的简写。

```js
const path =require('path')

module.exports={
  entry:"./src/main.js",
  output:{
    filename:"bundle.js",
    path:path.resolve(__dirname,'./build')
  },
  rules:[
    {
      test:/\.css$/,//正则表达式 .需要转译

      // loader:'css-loader'//loader写法 语法糖

      use:[
      //  {loader: 'css-loader'}
      'css-loader',
      ]

    }
  ]
}
```



## style-loader

css-loader只是负责将.css文件进行解析，并不会将解析之后的css插入到页面中;

如果我们希望再完成插入style的操作，需要另外一个loader，就是style-loader;

安装style-loader:

```bash
npm i style-loader -D
```

**配置方式**

**因为loader的执行顺序是从右向左(或者说从下到上，或者说从后到前的)**，所以我们需要将style- loader写到css-loader的前面;

```js
const path =require('path')

module.exports={
  entry:"./src/main.js",
  output:{
    filename:"bundle.js",
    path:path.resolve(__dirname,'./build')
  },
  module:{
    rules:[
      {
        test:/\.css$/,//正则表达式 .需要转译
        // loader:'css-loader'//loader写法 语法糖
        use:[
          'style-loader',//注意书写顺序,被依赖的写在后面
          'css-loader',
        ]
      }
    ]
  }
}
```

## 处理less文件

less、sass等编写的css需要通过工具转换成普通的css

我们可以使用**less工具(less Compiler)**来完成它的编译转换:

```bash
npm install less -D
```

执行如下命令:

(npx 到node_module文件夹下找到指定命令执行)

```bash
npx lessc ./test.less demo.css
```

### less-loader处理

在项目中我们会编写大量的css，它们如何可以自动转换呢?

使用less-loader，自动使用less工具转换less到css;

```bash
 npm install less-loader -D
```

配置webpack.config.js

```json
const path =require('path')

module.exports={
  entry:"./src/main.js",
  output:{
    filename:"bundle.js",
    path:path.resolve(__dirname,'./build')
  },
  module:{
    rules:[
      {//css
        test:/\.css$/,//正则表达式 .需要转译
        // loader:'css-loader'//loader写法 语法糖
        use:[
          'style-loader',//注意书写顺序,被依赖的写在后面
          'css-loader',
        ]
      },
      {//less
        test:/\.less$/,//正则表达式 .需要转译
        // loader:'css-loader'//loader写法 语法糖
        use:[
          'style-loader',//注意书写顺序,被依赖的写在后面
          'css-loader',
          'less-loader'
        ]
      },
      
    ]
  }
}
```



## PostCSS

PostCSS是一个通过JavaScript来转换样式的工具;

- 这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置; 
- 但是实现这些功能，我们需要借助于PostCSS对应的插件;

使用步骤:

第一步:查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader; 

第二步:选择可以添加你需要的PostCSS相关的插件;

### 命令行使用postcss

需要单独安装一个工具postcss-cli;

**安装:postcss、postcss-cli**

```bash
npm i postcss postcss-cli -D
```

> 我们编写一个需要添加前缀的css:
>
> ```css
> .title{
>   user-select: none;
> }
> ```
>
> https://autoprefixer.github.io/
>
> 我们可以在上面的网站中查询一些添加css属性的样式;

### autoprefixer插件

因为我们需要添加前缀，所以要安装**autoprefixer**:

```bash
npm install autoprefixer -D
```

直接使用postcss工具，并且制定使用autoprefixer

```bash
npx postcss --use autoprefixer -o demo.css testpostcss.css
```

转化之后的css样式如下:

```css
.title{
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

```

### postcss-loader

真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具:

在webpack中使用postcss就是使用**postcss-loader**来处理的

**安装postcss-loader:**

```bash
npm install postcss-loader -D
```

**修改加载css的loader**

- 因为postcss需要有对应的插件才会起效果，所以我们需要配置它的**plugin**;

```json
          {
            loader:'postcss-loader',
            options:{
              postcssOptions:{
                plugins:[
                  require('autoprefixer')
                ]
              }
            }
          }
```



### 单独的postcss配置文件

可以**将这些配置信息放到一个单独的文件中进行管理**:

在根目录下创建postcss.config.js

```js
module.exports={
  plugins:[
    require('autoprefixer')
  ]
}
```

```json
        use:[
          'style-loader',//注意书写顺序,被依赖的写在后面
          'css-loader',
          'postcss-loader'//已经设置了单独的postcss配置文件
        ]
```



### postcss-preset-env插件

在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。

我们可以使用另外一个插件:**postcss-preset-env**

**postcss-preset-env也是一个postcss的插件;**

- 可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境添加所需的polyfill;
- 也包括会自动帮助我们添加autoprefixer(所以相当于已经内置了autoprefixer);

**安装postcss-preset-env:**

```
npm install postcss-preset-env -D
```

之后，我们直接修改掉之前plugins的autoprefixer即可

```
module.exports={
  plugins:[
    require('postcss-preset-env')
  ]
}
```

